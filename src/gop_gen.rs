#![allow(warnings)]
/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___enable_if_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_type<_Default> = _Default;
pub type std___detector___is_detected = std_false_type;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___ptr_traits_elem {
    pub _address: u8,
}
impl Default for std___ptr_traits_elem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std___ptr_traits_elem_t = std___ptr_traits_elem;
pub type std___ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_ptr_to_element_type<_Elt> = _Elt;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___ptr_traits_impl {
    pub _address: u8,
}
pub type std___ptr_traits_impl___diff_t = [u8; 0usize];
pub type std___ptr_traits_impl___rebind = std___type_identity;
pub type std___ptr_traits_impl_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_impl_element_type<_Elt> = _Elt;
pub type std___ptr_traits_impl_difference_type = std___detected_or_t;
pub type std___ptr_traits_impl_rebind = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_pointer_traits {
    pub _address: u8,
}
impl Default for std_pointer_traits {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
impl<_Iterator> Default for std_reverse_iterator<_Iterator> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___new_allocator {
    pub _address: u8,
}
pub type std___new_allocator_value_type<_Tp> = _Tp;
pub type std___new_allocator_size_type = usize;
pub type std___new_allocator_difference_type = isize;
pub type std___new_allocator_pointer<_Tp> = *mut _Tp;
pub type std___new_allocator_const_pointer<_Tp> = *const _Tp;
pub type std___new_allocator_reference<_Tp> = *mut _Tp;
pub type std___new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___new_allocator_rebind {
    pub _address: u8,
}
pub type std___new_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std___allocator_base = std___new_allocator;
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
impl Default for std_allocator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
impl Default for std___allocator_traits_base___rebind {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = std___type_identity;
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
impl Default for std_allocator_traits__Size {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
pub type std__Base_bitset__WordT = ::std::os::raw::c_ulong;
pub type std_bitset__Base = u8;
pub type std_bitset__WordT = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_bitset_reference {
    pub _M_wp: *mut std_bitset__WordT,
    pub _M_bpos: usize,
}
impl Default for std_bitset_reference {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
impl Default for std__Vector_base__Vector_impl_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
impl Default for std__Vector_base__Vector_impl {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
impl Default for std__Vector_base {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = usize;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector__Temporary_value<_Tp> {
    pub _M_this: *mut std_vector,
    pub _M_storage: std_vector__Temporary_value__Storage<_Tp>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
#[repr(C)]
pub union std_vector__Temporary_value__Storage<_Tp> {
    pub _M_byte: ::std::os::raw::c_uchar,
    //pub _M_val: _Tp,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
}
impl<_Tp> Default for std_vector__Temporary_value__Storage<_Tp> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl<_Tp> Default for std_vector__Temporary_value<_Tp> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for std_vector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator___convertible_from = std___enable_if_t;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
impl<_Iterator> Default for __gnu_cxx___normal_iterator<_Iterator> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
impl Default for __gnu_cxx___alloc_traits {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct VkVideoGopStructure__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct VkVideoGopStructure {
    pub vtable_: *const VkVideoGopStructure__bindgen_vtable,
    pub m_gopFrameCount: i8,
    pub m_idrPeriod: i8,
    pub m_consecutiveBFrameCount: i8,
    pub m_gopFrameCycle: i8,
    pub m_temporalLayerCount: i8,
    pub m_lastFrameType: VkVideoGopStructure_FrameType,
    pub m_decodeOrderMap: std_vector,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum VkVideoGopStructure_FrameType {
    FRAME_TYPE_P = 0,
    FRAME_TYPE_B = 1,
    FRAME_TYPE_I = 2,
    FRAME_TYPE_IDR = 3,
    FRAME_TYPE_INTRA_REFRESH = 6,
    FRAME_TYPE_INVALID = -1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct VkVideoGopStructure_GopEntry {
    pub frameType: VkVideoGopStructure_FrameType,
    pub decodeOrder: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub references: u64,
}
#[test]
fn bindgen_test_layout_VkVideoGopStructure_GopEntry() {
    const UNINIT: ::std::mem::MaybeUninit<VkVideoGopStructure_GopEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkVideoGopStructure_GopEntry>(),
        16usize,
        concat!("Size of: ", stringify!(VkVideoGopStructure_GopEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVideoGopStructure_GopEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VkVideoGopStructure_GopEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure_GopEntry),
            "::",
            stringify!(frameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decodeOrder) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure_GopEntry),
            "::",
            stringify!(decodeOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).references) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure_GopEntry),
            "::",
            stringify!(references)
        )
    );
}
impl Default for VkVideoGopStructure_GopEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl VkVideoGopStructure_GopEntry {
    #[inline]
    pub fn isReference(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isReference(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isReference: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isReference: u8 = unsafe { ::std::mem::transmute(isReference) };
            isReference as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VkVideoGopStructure() {
    const UNINIT: ::std::mem::MaybeUninit<VkVideoGopStructure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VkVideoGopStructure>(),
        48usize,
        concat!("Size of: ", stringify!(VkVideoGopStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVideoGopStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(VkVideoGopStructure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gopFrameCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_gopFrameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idrPeriod) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_consecutiveBFrameCount) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_consecutiveBFrameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gopFrameCycle) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_gopFrameCycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_temporalLayerCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_temporalLayerCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastFrameType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_lastFrameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_decodeOrderMap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVideoGopStructure),
            "::",
            stringify!(m_decodeOrderMap)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19VkVideoGopStructure4InitEv"]
    pub fn VkVideoGopStructure_Init(this: *mut VkVideoGopStructure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN19VkVideoGopStructureC1EaaaaNS_9FrameTypeE"]
    pub fn VkVideoGopStructure_VkVideoGopStructure(
        this: *mut VkVideoGopStructure,
        gopFrameCount: i8,
        idrPeriod: i8,
        consecutiveBFrameCount: i8,
        temporalLayerCount: i8,
        lastFrameType: VkVideoGopStructure_FrameType,
    );
}
impl Default for VkVideoGopStructure {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl VkVideoGopStructure {
    #[inline]
    pub unsafe fn Init(&mut self) -> bool {
        VkVideoGopStructure_Init(self)
    }
    #[inline]
    pub unsafe fn new(
        gopFrameCount: i8,
        idrPeriod: i8,
        consecutiveBFrameCount: i8,
        temporalLayerCount: i8,
        lastFrameType: VkVideoGopStructure_FrameType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        VkVideoGopStructure_VkVideoGopStructure(
            __bindgen_tmp.as_mut_ptr(),
            gopFrameCount,
            idrPeriod,
            consecutiveBFrameCount,
            temporalLayerCount,
            lastFrameType,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure12GetFrameTypeEmbb"]
    pub fn VkVideoGopStructure_GetFrameType(
        this: *mut ::std::os::raw::c_void,
        frameNumInDisplayOrder: u64,
        firstFrame: bool,
        lastFrame: bool,
    ) -> VkVideoGopStructure_FrameType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure17PrintGopStructureEm"]
    pub fn VkVideoGopStructure_PrintGopStructure(this: *mut ::std::os::raw::c_void, numFrames: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure14VisitGopFramesEaRKSt8functionIFvaNS_9FrameTypeEEEbb"]
    pub fn VkVideoGopStructure_VisitGopFrames(
        this: *mut ::std::os::raw::c_void,
        gopNum: i8,
        callback: *const std_function,
        searchBackward: bool,
        searchForward: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure13GetReferencesEiRSt6bitsetILm64EE"]
    pub fn VkVideoGopStructure_GetReferences(
        this: *mut ::std::os::raw::c_void,
        gopNum: ::std::os::raw::c_int,
        refMask: *mut u64,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure19GetReferenceNumbersEaRSt6vectorIaSaIaEEbb"]
    pub fn VkVideoGopStructure_GetReferenceNumbers(
        this: *mut ::std::os::raw::c_void,
        gopNum: i8,
        refNumbers: *mut std_vector,
        searchBackward: bool,
        searchForward: bool,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK19VkVideoGopStructure21DumpFrameGopStructureEmbb"]
    pub fn VkVideoGopStructure_DumpFrameGopStructure(
        this: *mut ::std::os::raw::c_void,
        frameNumInInputOrder: u64,
        firstFrame: bool,
        lastFrame: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19VkVideoGopStructure21ComputeDecodeOrderMapEv"]
    pub fn VkVideoGopStructure_ComputeDecodeOrderMap(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std_vector_open0_VkVideoGopStructure_GopEntry_std_allocator_open1_VkVideoGopStructure_GopEntry_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_VkVideoGopStructure_GopEntry_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
